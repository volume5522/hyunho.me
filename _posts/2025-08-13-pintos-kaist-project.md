---
layout: post
title: Pintos Kaist Project
---

간단 운영체제 구현 프로젝트

**주제**: CPU와 메모리, 파일 시스템의 기초를 직접 구현하며 운영체제 원리 체득  
**깃허브** : [Github](https://github.com/volume5522/pintos-kaist.git)  
**개발 인원**: 3인 팀 과제  
**프로젝트 진행 일자**: 2025. 07. ~ 2025. 09.  
**맡은 역할**: 운영체제 뼈대 코드 분석 및 핵심 기능(프로세스 실행, 시스템 콜, 가상 메모리, fork) 직접 구현

---

### 프로젝트 배경

- **기획**  
  운영체제(리눅스·윈도우)는 프로그램 실행, 메모리 관리, 파일 입출력을 담당하는 “숨은 관리자”입니다.  
  Pintos는 교육용 소형 OS로, 이 핵심 기능들을 **직접 구현**해보는 프로젝트입니다.

- **기술**  
  단순히 코드 작성이 아니라,

  - ELF 실행 파일 로딩,
  - 스택 구성 및 사용자 모드 전환,
  - 시스템 콜(`read`, `write`, `fork` 등),
  - 가상 메모리(Page Table, Page Fault, Swap)  
    같은 운영체제의 핵심 메커니즘을 밑바닥부터 다뤄야 했습니다.

- **목표**  
  운영체제의 내부 동작을 실제 코드와 연결해 이해하고, 프로세스 실행부터 메모리 관리까지 전 과정을 직접 구축

---

### 프로젝트 문제

- **Argument Passing 오류**  
  스택에 `argv`를 올리는 과정에서 바이트 정렬, 포인터 배열 배치 오류 → 실행 불가
- **Starvation 오해**  
  Priority Donation이 모든 starvation을 해결한다고 착각 → locking 상황에만 유효하다는 점을 간과
- **Fork 디버깅 난관**  
  부모-자식 관계가 꼬여, 부모가 자식을 못 찾거나 트리 구조가 무너지는 현상 발생
- **VM 복잡성**  
  Page Fault 발생 시, SPT/Swap을 통해 복원해야 하는데 구현 미숙으로 커널 패닉 빈번

---

### 해결 과정

- **스택 초기화 정교화**: 스택 포인터 직접 조작, 패딩 및 문자열 정렬 처리
- **Starvation 개념 수정**: Donation은 Lock 기반 기아만 완화, Aging 등 별도 정책 필요 확인
- **Fork 버그 해결**: 팀원과 장시간 디버깅 후, 원인이 예상 밖으로 *initd 자식 연결 누락*임을 발견 → 수정 후 즉시 정상 동작
- **VM 구성**: SPT 설계 → Page Fault Handler로 CR2 레지스터 추적 → Swap In/Out 구현

---

### 결과

- **프로세스 실행**: ELF 로딩부터 사용자 모드 전환까지 정상 동작
- **시스템 콜**: 파일 입출력, 프로그램 실행/대기, fork 정상 동작
- **가상 메모리**: Lazy Loading, Swap 관리까지 구현 → 물리 메모리보다 큰 프로그램 실행 가능
- **디버깅 능력 강화**: “내가 건드린 함수만 의심하지 않는다”는 교훈 체득

---

### 기술적 의사결정 과정

- **자료구조**: Supplemental Page Table을 배열 대신 해시 기반으로 구현 → 빠른 탐색 보장
- **페이지 교체 정책**: 랜덤 교체 대신 LRU 기반 교체로 안정성 확보
- **협업 디버깅**: 팀 피드백(Starvation–Donation 관계 정리), initd 버그 발견 등 협업을 통한 문제 해결 경험

---

### 아키텍처 설명

- **프로세스 실행**:  
  ELF 실행 파일 → Loader로 세그먼트 로딩 → Stack 초기화(argv, argc) → CPU User Mode 전환

- **메모리 관리**:  
  가상 주소 → 페이지 테이블(PML4) → 물리 프레임 매핑 → Page Fault 시 SPT 확인 → 파일/Swap 복구

- **fork 구현**:  
  부모 주소 공간(Page Table) 복제 → 파일 디스크립터 참조 공유 → 레지스터(EAX=0) 재설정 → 자식 프로세스 실행

---

### 최종 교훈

- 수많은 버그와 디버깅을 거치며, 다음과 같은 문제 해결 과정을 거쳤습니다

| 문제 상황   | 대응                          |
| ----------- | ----------------------------- |
| 실행 실패   | 디버거로 레지스터·메모리 추적 |
| 레거시 코드 | 구조 파악 및 근본 원인 탐색   |

운영체제 개념과 실제 코드 구현을 연결하며 훈련하였음.

- **성과**

  - 복잡한 시스템 문제 분석 & 해결 능력 향상
  - 낯선 코드 기반을 빠르게 이해하는 역량 강화
  - 협업을 통한 문제 해결 경험 축적

- **마지막 깨달음**
  > “새로운 시스템이나 복잡한 문제를 마주했을 때, 빠르게 분석하고 해결할 수 있는 탄탄한 기반을 쌓았다.”
